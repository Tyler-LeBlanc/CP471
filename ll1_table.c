#include <search.h>
#include <stdio.h>

#define MAX_RULES 189

typedef struct
{
    char *non_terminal;
    char *terminal;
    char *production;
} ParsingRule;

// So the heap has the form non-terminal, terminal and production. It's a little confusion and awful to read
// If there is no terminal and it is just a non-terminal, then the terminal slot is the first char of the non-terminal it leads to.
// If there is a terminal then the terminal is just the terminal and the non terminal is epsilon.

ParsingRule parsing_table[MAX_RULES] = {
    {"program", "f", "fdecls decs st_seq ."},
    {"fdecls", "f", "fdec fdecls_"},
    {"fdecls_", "double", "ε"},
    {"fdecls_", ";", "; fdec fdecls_"},
    {"fdecls_", "int", "ε"},
    {"fdec", "d", "def type fname ( params ) decs st_seq fed"},
    {"params", "t", "type var params_"},
    {"params_", ",", ", type var params_"},
    {"params_", ")", "ε"},
    {"fname", "i", "id"},
    {"decs", "d", "decl decs_"},
    {"decs_", "print", "ε"},
    {"decs_", "while", "ε"},
    {"decs_", ";", "ε"},
    {"decs_", "if", "ε"},
    {"decs_", "fed", "ε"},
    {"decs_", ".", "ε"},
    {"decs_", "char", "ε"},
    {"decs_", "return", "ε"},
    {"decl", "t", "type varlist"},
    {"type", "i", "int"},
    {"type", "d", "double"},
    {"varlist", "v", "var , varlist_"},
    {"varlist_", "print", "ε"},
    {"varlist_", "while", "ε"},
    {"varlist_", ";", "ε"},
    {"varlist_", "if", "ε"},
    {"varlist_", "fed", "ε"},
    {"varlist_", ".", "ε"},
    {"varlist_", "char", "ε"},
    {"varlist_", ",", ", var varlist_"},
    {"varlist_", "return", "ε"},
    {"st_seq", "s", "statement ; st_seq"},
    {"statement", ";", "ε"},
    {"statement", "else", "ε"},
    {"statement", "od", "ε"},
    {"statement", "fed", "ε"},
    {"statement", ".", "ε"},
    {"statement", "fi", "ε"},
    {"statement", "v", "var = expr"},
    {"statement", "i", "if bexpr then st_seq st_seq_ fi"},
    {"statement", "w", "while bexpr do st_seq od"},
    {"statement", "p", "print expr"},
    {"statement", "r", "return expr"},
    {"st_seq_", "e", "else st_seq"},
    {"st_seq_", "fi", "ε"},
    {"expr", "t", "term expr_"},
    {"expr_", "and", "ε"},
    {"expr_", "then", "ε"},
    {"expr_", ";", "ε"},
    {"expr_", "else", "ε"},
    {"expr_", "+", "+ term expr_"},
    {"expr_", "-", "- term expr_"},
    {"expr_", ">=", "ε"},
    {"expr_", "<", "ε"},
    {"expr_", ">", "ε"},
    {"expr_", "==", "ε"},
    {"expr_", "od", "ε"},
    {"expr_", "do", "ε"},
    {"expr_", "fed", "ε"},
    {"expr_", ".", "ε"},
    {"expr_", "fi", "ε"},
    {"expr_", ",", "ε"},
    {"expr_", ")", "ε"},
    {"expr_", "or", "ε"},
    {"expr_", "<>", "ε"},
    {"expr_", "<=", "ε"},
    {"expr_", "]", "ε"},
    {"term", "f", "factor term_"},
    {"term_", "*", "* factor term_"},
    {"term_", "and", "ε"},
    {"term_", "then", "ε"},
    {"term_", ";", "ε"},
    {"term_", "else", "ε"},
    {"term_", '%', "% factor term_"},
    {"term_", "+", "ε"},
    {"term_", "-", "ε"},
    {"term_", "/", "/ factor term_"},
    {"term_", ">=", "ε"},
    {"term_", "<", "ε"},
    {"term_", ">", "ε"},
    {"term_", "==", "ε"},
    {"term_", "od", "ε"},
    {"term_", "do", "ε"},
    {"term_", "fed", "ε"},
    {"term_", ".", "ε"},
    {"term_", "fi", "ε"},
    {"term_", ",", "ε"},
    {"term_", ")", "ε"},
    {"term_", "or", "ε"},
    {"term_", "<>", "ε"},
    {"term_", "<=", "ε"},
    {"term_", "]", "ε"},
    {"exprseq", "e", "expr , exprseq_"},
    {"exprseq_", ",", ", expr exprseq_"},
    {"exprseq_", ")", "ε"},
    {"bexpr", "b", "bterm bexpr_"},
    {"bexpr_", "then", "ε"},
    {"bexpr_", "do", "ε"},
    {"bexpr_", ")", "ε"},
    {"bexpr_", "o", "or bfactor bterm_"},
    {"bterm", "b", "bfactor bterm_"},
    {"bterm_", "then", "ε"},
    {"bterm_", "do", "ε"},
    {"bterm_", ")", "ε"},
    {"bterm_", "or", "ε"},
    {"bterm_", "a", "and bfactor bterm_"},
    {"bfactor", "(", "( bexpr )"},
    {"bfactor", "e", "expr comp expr"},
    {"bfactor", "n", "not bfactor"},
    {"comp", "<", "<>"},
    {"comp", ">", ">="},
    {"comp", "=", "=="},
    {"var", "i", "id [ expr ]"},
    {"id", "l", "letter id_"},
    {"id_", "print", "ε"},
    {"id_", "(", "ε"},
    {"id_", "*", "ε"},
    {"id_", "and", "ε"},
    {"id_", "double", "ε"},
    {"id_", "while", "ε"},
    {"id_", "then", "ε"},
    {"id_", ";", "ε"},
    {"id_", "else", "ε"},
    {"id_", "if", "ε"},
    {"id_", '%', "ε"},
    {"id_", "+", "ε"},
    {"id_", "-", "ε"},
    {"id_", "/", "ε"},
    {"id_", "[", "ε"},
    {"id_", ">=", "ε"},
    {"id_", "int", "ε"},
    {"id_", "<", "ε"},
    {"id_", ">", "ε"},
    {"id_", "od", "ε"},
    {"id_", "do", "ε"},
    {"id_", "fed", "ε"},
    {"id_", ".", "ε"},
    {"id_", "char", "ε"},
    {"id_", "fi", "ε"},
    {"id_", ",", "ε"},
    {"id_", ")", "ε"},
    {"id_", "return", "ε"},
    {"id_", "or", "ε"},
    {"id_", "<>", "ε"},
    {"id_", "=", "ε"},
    {"id_", "<=", "ε"},
    {"id_", "]", "ε"},
    {"id_", "l", "letter id_"},
    {"id_", "d", "digit id_"},
    {"number", "i", "integer"},
    {"number", "D", "Double"},
    {"Double", "i", "integer . integer"},
    {"integer", "d", "digit integer_"},
    {"integer_", "*", "ε"},
    {"integer_", "and", "ε"},
    {"integer_", "then", "ε"},
    {"integer_", ";", "ε"},
    {"integer_", '%', "ε"},
    {"integer_", "+", "ε"},
    {"integer_", "-", "ε"},
    {"integer_", "/", "ε"},
    {"integer_", ">=", "ε"},
    {"integer_", "<", "ε"},
    {"integer_", ">", "ε"},
    {"integer_", "od", "ε"},
    {"integer_", "do", "ε"},
    {"integer_", "fed", "ε"},
    {"integer_", ".", "ε"},
    {"integer_", "fi", "ε"},
    {"integer_", ",", "ε"},
    {"integer_", ")", "ε"},
    {"integer_", "or", "ε"},
    {"integer_", "<>", "ε"},
    {"integer_", "<=", "ε"},
    {"integer_", "]", "ε"},
    {"integer_", "d", "digit integer_"},
    {"factor", "(", "( expr )"},
    {"factor", "v", "var"},
    {"factor", "n", "number"},
    {"factor", "f", "fname ( exprseq )"},
    {"letter", "c", "char"},
    {"digit", "n", "num"},
    {"digits_", "d", "digits_"},
    {"exponent", "E", "E sign digit digits_"},
    {"exponent", "e", "e sign digit digits_"},
    {"sign", "num", "ε"},
    {"sign", "+", "+"},
    {"sign", "-", "-"},
};

int main()
{
    printf("LL(1) Parsing Table Loaded. Use hash map lookup to access rules.\n");
    return 0;
}
